#------------------------------------------------------------------------------#
# 0. Introduction and Goals ----------------------------------------------------
{
  # This is the Iterator_Parameter_Dependents.R script.

  # The goal of this script is do define the higher-level functions in the 
  # Robusntess_Iterator.R script that need to know the user defined iterator 
  # parameters to function (see Iterator_Params.R). 

  # Of all the functions defined in this project, only  the functions below need
  # to be passed the iterator parameters in order to execute, and these 
  # functions are only called in the Robustness_Iterator.R and the 
  # Iterator_Params.R script. There is one function, summarise_Metadata, that 
  # both uses formals(fun) for iterator_parameters and also sets iterator 
  # parameters. As such, summarise_Metadata() could go in this script or the 
  # Iterator_Params.R script, but it's been saved in Iterator_Params.R.

  # The reason the functions below need to know the iterator parameters is to 
  # accurately name and describe the results produced by the iterator, whether
  # this be naming a save file or giving a plot description. 

  # Please read the documentation of the iterator and iterator parameters before
  # diving into this script.
  
}



#------------------------------------------------------------------------------#
# 1. Defining Functions---------------------------------------------------------

# auto_file_Name()
{
  #' Automatically generates a file name or file path
  #' 
  #' @param prefix As a char. What should the file name start with? It could be
  #' a folder to make it a file path, such as "Outputs/", or any other tag, or 
  #' "".
  #' 
  #' @param suffix As a char. What should the file name end with? It should be a 
  #' file extension such as ".txt" or ".RData" at minimum, but it could also be
  #' more, such as "report.txt".
  #' 
  #' @param time_of_run What time was this script run at? Used to tag file names
  #' with a unique descriptor that allows the user to associate all the saved 
  #' files of the iterator together (the logs at 9:32 refer to the plot at 9:32 
  #' and the environment saved at 9:32). It also ensures that files from the 
  #' next time you run the iterator never overwrite old ones. Should always be 
  #' passed the time_of_run char generated by create_Params().
  #' 
  #' @param dilution_params What arguments were used in dilution robustness?
  #' This function will add the most relevant dilution parameters to the file 
  #' name. Should always be passed formals(wrap_resource_Robustness()).
  #' 
  #' @param meta_params What meta_data parameters were specified for the 
  #' iterator? If this was specified as a trial run of the iterator, file names
  #' are tagged with "TRIAL_RUN". Should always be passed 
  #' formals(summarise_Metadata).
  #' 
  #' @param testdata_type What type of testdata was used in the iterator? This
  #' function adds the testdadta type into the file name. Should always be 
  #' passed formals(extract_Testdata)$testdata_type.
  #' 
  #' @return A file name that starts with the prefix, ends with the suffix and 
  #' contains a bunch of parameter tags in between. This way the user can 
  #' identify the save file by the parameters it was set up with.
  
  
  auto_file_Name <- function(prefix,
                             suffix,
                             
                             trial_run,
                             preserve_topology,
                             testdata_type,
                             feature_type,
                             number_ranks,
                             time_of_run) {
    
    # We define individual comments related to relevant parameters and then 
    # string them all together for the save file name.
    
    # If this is a trial run, mark the save files as such
    if (trial_run == FALSE) {
      
      test_run_comment <- ""
      
    } else if (trial_run == TRUE) {
      
      test_run_comment <- "TRIAL_RUN_"
      
    }
    
    
    # How was the topology of diluted resources handled? Make an appropiate 
    # comment.
    if (preserve_topology == FALSE) {
      topology_comment <- "random_topology_"
      
    } else if (preserve_topology == TRUE) {
      topology_comment <- "preserved_topology_"
      
    }
    
    
    # Â´What testdata_type was extracted and used with resource_Robustness?
    testdata_comment <-
      str_glue(testdata_type, "_")
    
    
    # What feature_type was dilution specified to occur with?
    feature_type_comment <-
      str_glue(feature_type, "_")
    
    
    # Make a comment out of the median top_n that was considered top_ranked. 
    # As a note, it could be a different number per method, but often it will
    # be the same number for every method.
    top_ranks_comment <-
      str_glue("top", median(unlist(number_ranks)), "_", )
    
    
    # Mash all the comments together with the suffix and prefix to create our
    # custom and hopefully informative file names
    auto_file_name <-
      str_glue(
        prefix,
        test_run_comment,
        testdata_comment,
        topology_comment,
        feature_type_comment,
        top_ranks_comment,
        time_of_run,
        suffix
      )
    
    return(auto_file_name)
  }  # end of function
  
}


# auto_plot_Description()
{
  #' Automatically creates a verbose caption of a top ranks overlap plot
  #' 
  #' @param top_ranks_overlap As a tibble in the form of a extract_top_ranks 
  #' output, though ideally it will be preprocessed for plotting (better method 
  #' names, no NAs, etc.). This is the top_ranks_overlap that would be plotted
  #' with this caption. The function takes data from the tibble's general 
  #' structure to describe it accurately. 
  #' 
  #' @param time_of_run What time was this script run at? Used to tag the plot
  #' with a unique descriptor that allows the user to associate it with all the 
  #' saved files. Should always be passed the time_of_run char generated by 
  #' create_Params().
  #' 
  #' @param dilution_params What arguments were used in dilution robustness?
  #' This function will add the most relevant dilution parameters to the 
  #' description. Should always be passed formals(wrap_resource_Robustness).
  #' 
  #' @param meta_params What meta_data parameters were specified for the 
  #' iterator? If this was specified as a trial run of the iterator, the 
  #' description is marked with "TRIAL_RUN". Should always be passed 
  #' formals(summarise_Metadata).
  #' 
  #' @param testdata_type What type of testdata was used in the iterator? This
  #' function adds the testdadta type to the description. Should always be 
  #' passed formals(extract_Testdata)$testdata_type.
  
  auto_plot_Description <- function(top_ranks_overlap,
                                    
                                    trial_run,
                                    preserve_topology,
                                    testdata_type,
                                    feature_type,
                                    number_ranks,
                                    time_of_run) {
    
    ## General comment, on testdata type, feature_type and topology
    {
      if (preserve_topology == FALSE) {
        topology_comment <- "random_Dilute()"
        
      } else if (preserve_topology == TRUE) {
        topology_comment <- "preserve_Dilute()"
        
      }
      
      
      general_comment <-
        str_glue(
          "This plot was created using the ",
          testdata_type,
          " data. Dilution was performed using ",
          feature_type,
          " features and the ",
          topology_comment,
          " function. "
        )
      
      rm(topology_comment)
    }
    
    
    
    ## Dilution comment, on proportions
    {
      dilution_overview <- count(top_ranks_overlap,
                                 dilution_prop,
                                 run_mode = "real")
      
      
      dilution_comment <- str_glue(
        "The dilution occured in ",
        dilution_overview$dilution_prop[2] -
          dilution_overview$dilution_prop[1],
        " % increments up to a maximum of ",
        max(top_ranks_overlap$dilution_prop),
        " %. "
      )
      
      if (nrow(dilution_overview) < 1) {
        stop(
          "Expected at least two dilution proportions in input (0, and one ",
          "more. But found only one instead, namely ",
          dilution_overview$dilution_prop
        )
      }
      
      if (length(unique(dilution_overview$n)) != 1) {
        stop(
          "There should be an equal number of samples for every dilution, ",
          "but there is not."
        )
      }
      
      
      rm(dilution_overview)
      
    }
    
    
    ## Nperms and top_ranks comment
    {
      top_ranks_vector <- unlist(number_ranks)
      
      permutations_overview <- top_ranks_overlap %>%
        filter(dilution_prop == 0) %>%
        count(Method)
      
      
      top_ranks_permutations_comment <-
        str_glue(
          "The overlap was compared between the ",
          median(top_ranks_vector),
          " highest ranked interactions over ",
          permutations_overview$n[1],
          " permutations."
        )
      
      if (length(unique(permutations_overview$n)) != 1) {
        stop(
          "There should be an equal number of samples for each method at , ",
          "dilution proportion 0, but there is not."
        )
      }
      
      rm(permutations_overview, top_ranks_vector)
    }
    
    
    ## Date and time comment
    time_comment <- str_glue("Generated at ",
                             time_of_run,
                             ".")
    
    
    ## Assemple plotting caption
    plotting_caption <-
      str_glue(
        general_comment,
        "\n",
        dilution_comment,
        "\n\n",
        top_ranks_permutations_comment,
        "\n",
        time_comment
      )
    
    
    ## Add addendum if trial run
    if (trial_run == TRUE) {
      plotting_caption <-
        str_glue(plotting_caption, "   --   [TRIAL RUN]")
    }
    
    return(plotting_caption)
  }  # end of function
  
}


# save_Results()
{
  #' 
  #'
  #'
  #'
  #'
  #'
  
  save_Results <- function(plot_box,
                           plot_line,
                           iterator_results,
                           
                           trial_run,
                           preserve_topology,
                           testdata_type,
                           feature_type,
                           number_ranks,
                           time_of_run) {
    
    # Generate the filepaths to save the data under
    box_plot_png_name <-
      auto_file_Name(
        prefix = "Boxplot_Resource_Dilution_",
        suffix = ".png",
        
        preserve_topology  = preserve_topology,
        testdata_type      = testdata_type,
        feature_type       = feature_type,
        number_ranks       = number_ranks,
        time_of_run        = time_of_run,
        trial_run          = trial_run)
    
    line_plot_png_name <-
      auto_file_Name(
        prefix = "Lineplot_Resource_Dilution_",
        suffix = ".png",
        
        preserve_topology  = preserve_topology,
        testdata_type      = testdata_type,
        feature_type       = feature_type,
        number_ranks       = number_ranks,
        time_of_run        = time_of_run,
        trial_run          = trial_run)
    
    iterator_results_save_path <- 
      auto_file_Name(
      prefix = "Outputs/Resource_Dilution/Iterator_Results_",
      suffix = ".RData",
      
      preserve_topology  = preserve_topology,
      testdata_type      = testdata_type,
      feature_type       = feature_type,
      number_ranks       = number_ranks,
      time_of_run        = time_of_run,
      trial_run          = trial_run)
    
    
    
    
    # Save both plots
    ggsave(
      plot = plot_box,
      box_plot_png_name,
      height = 7.75,
      width = 8.00,
      path = "Outputs/Resource_Dilution"
    )
    
    ggsave(
      plot = plot_line,
      line_plot_png_name,
      height = 9.00,
      width = 8.00,
      path = "Outputs/Resource_Dilution"
    )
    
    # Save R environment and all the results within it
    save(iterator_results, file = iterator_results_save_path)
    
    
    
    
    # Let the user know where everything was stored.
    print(str_glue("Box Plot saved at ~/Outputs/Resource_Dilution/",
                   box_plot_png_name, "."))
    
    print(str_glue("Line Plot saved at ~/Outputs/Resource_Dilution/",
                   line_plot_png_name, "."))
    
    print(str_glue("Iterator Results saved at ~/",
                   iterator_results_save_path, "."))
    
  }  # end of function
}



