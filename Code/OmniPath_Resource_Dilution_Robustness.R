
#' Analyses LIANA prediction robustness when diluting resources
#'
#' @description This is not really a function, it is a full fledged script that
#' needs to be iterated easily and conveniently. Please familiarize yourself 
#' with the code before using this script, it is well commented throughout.
#' 
#' In brief, this script runs five LIANA methods from LIANA++ (call_connectome,
#' call_natmi, call_italk, call_sca and cellchat) on one benchmarking data set
#' and stores their predictions for which are the top most relevant CCIs
#' occuring. The resource used is OmniPath.
#' 
#' Using this information, we use resource_Dilute() on OmniPath. This process 
#' removes a proportion of interactions from OmniPath, and replaces them with
#' spurious interactions derived from mixing and matching genes extracted from
#' the testdata. Interactions that were ranked as relevant CCIs are excluded
#' from dilution. It is not uncommon to generate a gradient of dilution, say 
#' 10 % to 80 % in 10 % intervals.
#' 
#' LIANA is rerun on the diluted resources. For each result the top ranked CCIs
#' are extracted and compared to the original predictions. The overlap, mismatch
#' and proportion of diluted interactions among original top_ranked ones are
#' recorded and stored. Finally, all the relevant data generated by this 
#' function is returned in a list.
#' 
#' @param testdata_type This script automatically grabs data from the Data
#' folder. Choose "liana_test" to get the smaller data frame stored in the 
#' LIANA package, or "seurat_pbmc" to use the PBMC data from the Seurat 
#' tutorial.
#' 
#' @param feature_type Should dilution occur with all the genes profiled in
#' testdata (choose "generic") or with the most variable features (choose 
#' "variable").
#' 
#' @param preserve_topology When diluting, two methods are implemented.
#' random_Dilute makes only a small effort to preserve the topology of the rows
#' that are diluted from resource, preserve_Dilute makes a far greater effort.
#' Choose TRUE for preserve_Dilute and FALSE for random_Dilute.
#' 
#' @param dilution_props A sequence of numerics (0-1) that indicate which 
#' proportions to dilute the resource with. For example c(0.1, 0.2, 0.3) would
#' compare the top ranked CCI's using undiluted OmniPath compared to OmniPath 
#' with 10 % of its rows diluted, undiluted vs 20 % diluted, and undiluted vs
#' 30 % diluted.
#' 
#' @param outputs Which outputs of the calculation would you like to return? 
#' By default, all the method results, resources used, top ranked CCIs, analysis 
#' of top ranks, script parameters and the chosen testdata are returned in a
#' list. Construct an atomic vector using all or some of "liana_results_OP", 
#' "resources_OP", "top_ranks_OP", "top_ranks_analysis","metadata", and 
#' "testdata" to tell the script which outputs should go in the returned list.
#' It's probably best to run this once with testdata to better understand which
#' list element holds which data, and then pair it down to what is needed.
#' 
#' @param number_ranks A named list. Each item is named after a method and is 
#' equal to the number of top interactions considered relevant for that method. 
#' 
#' For example, item one on the list may be called call_connectome and be equal 
#' to 500. This would signal to the function that for call_connectome, the top 
#' 500 CCI's are considered relevant and that these 500 are the ones that are to
#' be compared between the dilutions.
#' 
#' @param master_seed  At some stages when diluting  a resource, randomness
#' is at play. Setting a master seed will ensure that dilute_Resource(), the 
#' function that dilutes the resources, runs the same way every time. Each 
#' instance of randomness within the scope of dilute_Resource() will run 
#' reproducibly.
#' 
#' @param methods_vector Which methods should the function run? Choose from
#' "call_connectome", "call_natmi", "call_italk", "call_sca" and "cellchat".
#' Supply the argument in the form of e.g. c("call_conncectome, "call_italk").
#' 
#' @param cellchat_nperms Cellchat is one of the slower methods, for test runs
#' it may be useful to set this parameter to 10 to speed up the analysis.
#'
#' @param sink_otuput TRUE or FALSE. Should the function save a full log of the 
#' Console Output as a log to the log folder? Warnings and messages will not be 
#' visible in the console output if this is enabled, so unless there is a reason
#' why such a record is necessary this option is not recommended.
#' 
#' @param liana_warnings Either TRUE, FALSE or "divert". Should the warnings 
#' from liana, which are often repetitive and unhelpful, be either suppressed or 
#' alternatively diverted to the log folder? When these types of warning are 
#' left in, they can often displace valuable warnings. Be careful with this 
#' setting, as suppressing warnings is obviously risky.
#' 
#' @param sink_logfile Only if sink_output == TRUE. As a char, under what file 
#' path (including the name of the log) should your sunk output be stored? For 
#' example, "Outputs/Logs/Complete_Log_xyz.txt" would store the log in the logs
#' folder of outputs, under the name "Complete_Log_xyz.txt".
#'  
#' @param warning_logfile Only if liana_warnings == "divert". Same idea as 
#' sink_logfile.
#' 
#' @return Depending on outputs arg, a list with many possible contents is 
#' returned.

dilution_Robustness <- function(testdata_type,
                                feature_type,
                                preserve_topology,
                                dilution_props,
                                number_ranks,
                                master_seed,
                                outputs = c("liana_results_OP",
                                            "resources_OP",
                                            "top_ranks_OP",
                                            "top_ranks_analysis",
                                            "metadata", 
                                            "testdata"),
                                
                                methods_vector =  c('call_connectome',
                                                    'call_natmi', 
                                                    'call_italk',
                                                    'call_sca',
                                                    'cellchat'),
                                cellchat_nperms = 100,
                                sink_output     = FALSE,
                                liana_warnings  = TRUE,
                                sink_logfile    = "",
                                warning_logfile = "") {
  
runtime <- list()
runtime[[str_glue("Iteration Start - Seed ", master_seed)]] <- Sys.time()

# Sanitize master_seed input
master_seed <- floor(master_seed)

print_Title(str_glue("Iteration ", 
                     master_seed, 
                     "  --  At ", 
                     as.character(Sys.time())),
            super = TRUE)


#------------------------------------------------------------------------------#
# 0. Preparing Logs ------------------------------------------------------------
{
  print_Title(
    str_glue("0. Sinking Outputs", "                      --  Iteration ",
             master_seed))
  # 0.1 Sinking Outputs
  {
    

  if(sink_output == TRUE) {
  
    connection <- file(sink_logfile, open = "at")
    sink(connection, append=TRUE, type = "output", split = TRUE)
    sink(connection, append=TRUE, type="message")
    
    
  } 
    
    
  } # end of subpoint
  
  # 0.2 Printing Iteration Header to Warnings Log
  {
    
    
  if(liana_warnings == "divert") {
    
    cat(str_glue("|=======================================",
                 "=======================================|"),
        "\n\n",
        str_glue(as.character(Sys.time()), ": Iteration  --  ", master_seed), 
        "\n\n\n",
        file = warning_logfile, 
        append = TRUE)

  } 
    
    
  } # end of subpoint
  
}



#------------------------------------------------------------------------------#
# 1. Preparing resource_Dilute() Inputs ----------------------------------------
{
  print_Title(
    str_glue("1. Preparing resource_Dilute() Inputs", "   --  Iteration ", 
             master_seed))
  
  # 1.1 Running LIANA wrapper
  {
    
  # Get seurat or liana test data
  if (testdata_type == "seurat_pbmc") {
    
    testdata <- readRDS(file = "Data/pbmc3k_final.rds")     
    
    
    
  } else if (testdata_type == "liana_test") {
    
    liana_path <- system.file(package = 'liana')       
    testdata <- 
      readRDS(file.path(liana_path, "testdata", "input", "testdata.rds"))   
    
    # removing superfluous values
    rm(liana_path)
    
    
    
  } else {
    
    warning("Testdata name not recognized!")
    
  }
  
  
  # Generate Undiluted liana results by running wrapper function
  # Omnipath x the methods vector, on the selected data
  
  # NATMI results are contaminated with results from earlier runs if you
  # don't specify a special output folder for the results to go in
  
  natmi_output <-  Sys.time()           %>%
    as.character()       %>%
    gsub(':', '_', .)    %>% 
    gsub('-', '_', .)    %>% 
    gsub(' ', '_', .)    %>%
    str_glue('Test_', .)
  
  # The if statements give the user control over how warnings are handled
  if (liana_warnings == TRUE) {
    
    liana_results_OP_0 <- 
      liana_wrap(testdata, 
                 method = methods_vector, 
                 resource = c('OmniPath'), 
                 expr_prop = 0,
                 cellchat.params   = list(nboot = cellchat_nperms, 
                                          expr_prop = 0,
                                          thresh = 1),
                 call_natmi.params = list(output_dir = natmi_output))
    
    
  } else if (liana_warnings == "divert") {
    
    divert_Warnings(
      {    
        liana_results_OP_0 <- 
          liana_wrap(testdata, 
                     method = methods_vector, 
                     resource = c('OmniPath'), 
                     expr_prop = 0,
                     cellchat.params   = list(nboot = cellchat_nperms, 
                                              expr_prop = 0,
                                              thresh = 1),
                     call_natmi.params = list(output_dir = natmi_output))
        
      }, logFile = warning_logfile)
    
  } else if (liana_warnings == FALSE) {
    
    suppressWarnings(
      {    
        liana_results_OP_0 <- 
          liana_wrap(testdata, 
                     method = methods_vector, 
                     resource = c('OmniPath'), 
                     expr_prop = 0,
                     cellchat.params   = list(nboot = cellchat_nperms, 
                                              expr_prop = 0,
                                              thresh = 1),
                     call_natmi.params = list(output_dir = natmi_output))
        
      })
    
  }

  
  if (length(methods_vector) == 1) {
    
    liana_results_OP_0 <- list(liana_results_OP_0)
    
    names(liana_results_OP_0) <- methods_vector
  
  }
  
  
  
  
  # Update runtime
  runtime[["First Liana"]] <- Sys.time()
  
  
  # Remove superfluous variables
  rm(natmi_output)
  
  } # end of subpoint

  # 1.2 Get highest ranked interactions for undiluted conditions 
  {
    
    
  # Apply get_top_n_ranks for each method's results on OP_0 (i.e. undiluted)
  top_ranks_OP_0 <- list()
  
  for (method in methods_vector){
    
    # Because cellchat produces so many interactions all tied for 0, we need
    # to cut with ties
    if(method == "cellchat") {
      
      top_ranks_OP_0[[method]] <- 
        get_top_n_ranks(data_set  = liana_results_OP_0[[method]],
                        top_n     = number_ranks[[method]],
                        method    = method,
                        with_ties = TRUE)
      
    } else {
      
      top_ranks_OP_0[[method]] <- 
        get_top_n_ranks(data_set  = liana_results_OP_0[[method]],
                        top_n     = number_ranks[[method]],
                        method    = method,
                        with_ties = FALSE)
      
    }

    
  }
  
  # an interesting note here is that NATMI produces far more unique LR Pairs in 
  # its top rankings than other methods. Cellchat identifies less for example, 
  # filling its top 1000 (or n) by repeating those interactions between many
  # combinations of source cell clusters and target cell clusters.
  # NATMI repeats its interactions less, providing more unique LR pairs than
  # cellchat. In exchange it only finds these interacting pairs more rarely 
  # between cell clusters.
  
  
    
  } # end of subpoint
  
  # 1.3 Format OmniPath and filter non-hits
  {
    
  
  # Format OmniPath_0 to be easier to work with and to pair it down to the 
  # columns relevant for the methods. Also add the isRandom column which 
  # indicates whether an interaction has been randomly generated and the LR_Pair
  # columns, which helps identify individual interactions
  OmniPath_0 <- select_resource(c('OmniPath'))[["OmniPath"]] %>%
    select(source_genesymbol,
           target_genesymbol,
           is_directed,
           is_stimulation,
           consensus_stimulation,
           is_inhibition,
           consensus_inhibition,
           category_intercell_source,
           category_intercell_target,
           genesymbol_intercell_source,
           genesymbol_intercell_target,
           entity_type_intercell_target,
           sources,
           references,
           entity_type_intercell_source,
           entity_type_intercell_target) %>%
    mutate(isRandom = FALSE) %>%
    unite("LR_Pair", 
          c(source_genesymbol, target_genesymbol), 
          remove = FALSE, 
          sep = "_") %>%
    relocate("LR_Pair", .after = last_col())
  
  # Filter OmniPath to only include interactions between genes which are 
  # represented in the data. 
  # This has no impact on the results, since the removed interactions can't be
  # evaluated by the methods as the necessary genes are missing.
  # The advantage here is that dilution later replaces genes from the resource
  # with genes in the data set
  # If we consider genes in the resource that are also represented in the data
  # 'hits', then we are diluting the resource by inserting hits.
  # Making sure OP only had hits to begin with ensures we dilute hits with 
  # other hits, a fairer comparison than the alternative, which would be 
  # diluting hits and non-hits from OP with hits from the data.
  gene_names <- rownames(testdata@assays$RNA@data)
  
  OmniPath_0 <- OmniPath_0 %>%
    filter(source_genesymbol %in% gene_names) %>%
    filter(target_genesymbol %in% gene_names)
  
  # removing superfluous values
  rm(gene_names)
  
  
    
  } # end of subpoint
  
  # 1.4 Listify Data sets in the face of dilution steps
  {
  
  
  # Since we are about to perform the same analysis in the steps above but 
  # multiplied by each dilution step, we will turn our data sets into named 
  # lists sorted by method and sub categorized by dilution.
  
  #relist all our data into three concise named lists of named lists
  resources_OP <- list("call_connectome" = list(OmniPath_0 = OmniPath_0),
                       "call_natmi"      = list(OmniPath_0 = OmniPath_0),
                       "call_italk"      = list(OmniPath_0 = OmniPath_0),
                       "call_sca"        = list(OmniPath_0 = OmniPath_0),
                       "cellchat"        = list(OmniPath_0 = OmniPath_0))
  
  
  
  liana_results_OP <- 
    list("call_connectome" = list(OmniPath_0 = liana_results_OP_0$call_connectome),
         "call_natmi"      = list(OmniPath_0 = liana_results_OP_0$call_natmi),
         "call_italk"      = list(OmniPath_0 = liana_results_OP_0$call_italk),
         "call_sca"        = list(OmniPath_0 = liana_results_OP_0$call_sca),
         "cellchat"        = list(OmniPath_0 = liana_results_OP_0$cellchat))
  
  
  
  
  top_ranks_OP <- 
    list("call_connectome" = list(OmniPath_0 = top_ranks_OP_0$call_connectome),
         "call_natmi"      = list(OmniPath_0 = top_ranks_OP_0$call_natmi),
         "call_italk"      = list(OmniPath_0 = top_ranks_OP_0$call_italk),
         "call_sca"        = list(OmniPath_0 = top_ranks_OP_0$call_sca),
         "cellchat"        = list(OmniPath_0 = top_ranks_OP_0$cellchat))
  
  # filter lists to only contain data relevant to the selected methods_vector
  resources_OP     <- resources_OP[methods_vector]
  liana_results_OP <- liana_results_OP[methods_vector]
  top_ranks_OP     <- top_ranks_OP[methods_vector]
  
  
  
  # remove old data frames
  rm(OmniPath_0, liana_results_OP_0, top_ranks_OP_0)
  
  
    
  } # end of subpoint
  
}



#------------------------------------------------------------------------------#
# 2. Diluting Resources ------------------------------------------------------
{
  print_Title(
    str_glue("2. Diluting Resources", "                   --  Iteration ", 
             master_seed))
  
  # 2.1 Generate diluted Resources for all methods
  {
  
  
  # Generating a unified top_rank_list
  top_rank_list <- unique(c(top_ranks_OP$call_connectome$OmniPath_0$LR_Pair,
                            top_ranks_OP$call_natmi$OmniPath_0$LR_Pair,
                            top_ranks_OP$call_italk$OmniPath_0$LR_Pair,
                            top_ranks_OP$call_sca$OmniPath_0$LR_Pair,
                            top_ranks_OP$cellchat$OmniPath_0$LR_Pair))
  
  # Initiating a list of all dilutions
  dilutions_OP <- list()
  
  # Iterate over every method, lapply over every dilution proportion
  
  for (method in methods_vector){
    
    dilutions_OP[[method]] <- 
      lapply(dilution_props, dilute_Resource, 
             resource          = resources_OP[[method]]$OmniPath_0, 
             top_rank_list     = top_rank_list, 
             preserve_topology = preserve_topology,
             data_set          = testdata,
             feature_type      = feature_type,
             verbose           = TRUE, 
             master_seed       = master_seed)
    
  }
  
  
  
  # Merge OP_0 with the rest of the dilutions, could use mapply but its less 
  # consistent
  for (method in methods_vector) {
    for (dilution in names(dilution_props)) {
      
      resources_OP[[method]][[dilution]] <- dilutions_OP[[method]][[dilution]]
      
    }
  }
  
  
  # Remove uneccesary Variables
  rm(dilutions_OP, method, dilution, top_rank_list)
  
  
  
  } # end of subpoint
  
}    



#------------------------------------------------------------------------------#
# 3. Rerun Liana and contrast predictions --------------------------------------
{
  print_Title(
    str_glue("3. Rerun Liana and contrast predictions","  --  Iteration ", 
             master_seed))
  
  # 3.1 Reapply individual methods with diluted resources
  {
  # results still growing somehow, don't know why (natmi and others)
  # in some cases the defaults assosciated with liana_wrap are explicitly applied
  
  # Initialize a list for liana results using diluted resources
  liana_dilutions_OP <- list()
  
  runtime[["Resource Dilution"]] <- Sys.time()
  
  # lapply liana wrap accross the diluted resources for every method 
  
  # NATMI results are contaminated with results from earlier runs if you
  # don't specify a special output folder for the results to go in
  
  natmi_output <-  Sys.time()           %>%
    as.character()       %>%
    gsub(':', '_', .)    %>% 
    gsub('-', '_', .)    %>% 
    gsub(' ', '_', .)    %>%
    str_glue('Test_', .)
  
  if (liana_warnings == TRUE) {
    
    for (method in methods_vector) {
      
        liana_dilutions_OP[[method]] <-
          lapply(resources_OP[[method]][-1], 
                 liana_wrap,
                 seurat_object     = testdata,
                 method            = method,
                 resource          = c('custom'),
                 expr_prop         = 0,
                 cellchat.params   = list(nboot     = cellchat_nperms, 
                                          expr_prop = 0,
                                          thresh    = 1),
                 call_natmi.params = list(output_dir = natmi_output))
      
      
      runtime[[str_glue(str_to_title(method), " rerun")]] <- Sys.time()
      
    }
    
  } else if (liana_warnings == "divert") {
    
    for (method in methods_vector) {
      
      divert_Warnings(
        {    
          
          liana_dilutions_OP[[method]] <-
            lapply(resources_OP[[method]][-1], 
                   liana_wrap,
                   seurat_object     = testdata,
                   method            = method,
                   resource          = c('custom'),
                   expr_prop         = 0,
                   cellchat.params   = list(nboot     = cellchat_nperms, 
                                            expr_prop = 0,
                                            thresh    = 1),
                   call_natmi.params = list(output_dir = natmi_output))
        
        }, logFile = warning_logfile)
      
      
      
      runtime[[str_glue(str_to_title(method), " rerun")]] <- Sys.time()
      
    }
    
  } else if (liana_warnings == FALSE) {
    
    for (method in methods_vector) {
      
      suppressWarnings(
        {    
          
          liana_dilutions_OP[[method]] <-
            lapply(resources_OP[[method]][-1], 
                   liana_wrap,
                   seurat_object     = testdata,
                   method            = method,
                   resource          = c('custom'),
                   expr_prop         = 0,
                   cellchat.params   = list(nboot     = cellchat_nperms, 
                                            expr_prop = 0,
                                            thresh    = 1),
                   call_natmi.params = list(output_dir = natmi_output))
        
        })
      
      runtime[[str_glue(str_to_title(method), " rerun")]] <- Sys.time()
      
    }
  }
  

    
    
    
    
    # Merge with undiluted results, could use mapply but its less consistent
    for (method in methods_vector) {
      for (dilution in names(dilution_props)) {
        
        liana_results_OP[[method]][[dilution]] <- 
          liana_dilutions_OP[[method]][[dilution]]
        
      }
    }
    
    
    # Remove uneccesary Variables
    rm(liana_dilutions_OP, method, dilution, natmi_output)
    
    
    
  } # end of subpoint
  
  # 3.2 Get top_n_ranks for each method and dilution
  {
    
  
  # lapply get_top_n_ranks over the dilution stages and save results in 
  # top_dilutions list
  top_dilutions_OP <- list()
  
  
  top_dilutions_OP[["call_connectome"]] <- 
    lapply(liana_results_OP$call_connectome[-1], get_top_n_ranks, 
           method = "call_connectome", top_n = number_ranks$call_connectome)
  
  top_dilutions_OP[["call_natmi"]] <-
    lapply(liana_results_OP$call_natmi[-1], get_top_n_ranks,
           method = "call_natmi", top_n = number_ranks$call_natmi)
  
  top_dilutions_OP[["call_italk"]] <- 
    lapply(liana_results_OP$call_italk[-1], get_top_n_ranks, 
           method = "call_italk", top_n = number_ranks$call_italk)  
  
  top_dilutions_OP[["call_sca"]] <- 
    lapply(liana_results_OP$call_sca[-1], get_top_n_ranks, 
           method = "call_sca", top_n = number_ranks$call_sca)  
  
  # Because cellchat produces so many interactions all tied for 0, we need
  # to cut with ties
  top_dilutions_OP[["cellchat"]] <- 
    lapply(liana_results_OP$cellchat[-1], 
           get_top_n_ranks, 
           method = "cellchat", 
           top_n = number_ranks$cellchat,
           with_ties = TRUE)  
  
  
  # This list could be filtered to only include results for methods in 
  # methods_vector but it's about to be deleted anyway.
  
  
  
  # Merge with undiluted results, could use mapply but its less consistent
  for (method in methods_vector) {
    for (dilution in names(dilution_props)) {
      
      top_ranks_OP[[method]][[dilution]] <- 
        top_dilutions_OP[[method]][[dilution]]
      
    }
  }
  
  # Remove superfluous values
  rm(top_dilutions_OP, method, dilution)
  
  
  
  
  
  
  # Formatting of top ranks
  
  # format top_ranks to have an ID that marks each specific interaction (LR and 
  # the source and target cell)
  for (method in methods_vector) {
    
    top_ranks_OP[[method]] <- 
      lapply(top_ranks_OP[[method]], unite, col = "LR_ID", 
             c(source, target, ligand, receptor), remove = FALSE)
    
  
  }
  
  
  # add a column to see if an interaction is fake
  for (method in methods_vector) {
    for (dilution in c("OmniPath_0", names(dilution_props))) {
      if( !(is_null(top_ranks_OP[[method]][[dilution]]))) {
        
        top_ranks_OP[[method]][[dilution]] <- 
          top_ranks_OP[[method]][[dilution]] %>%
          mutate(isRandom = 
                   !(LR_Pair %in% resources_OP[[method]]$OmniPath_0$LR_Pair))
        
        
      } else {
        
        warning("One of the top_rank tibbles is missing! Moving on.")
        
      }
    }
  }
  
  # remove superfluous values
  rm(method,dilution)
  
    
  } # end of subpoint
  
  #3.3 Analysis of top_ranks
  {
  # Legend to what factors we look to analyse. Overlap is most important, the
  # rest interesting mostly in edge cases:
  #
  # Overlap               = What proportion of top ranked interactions 
  #                         (L + R + Source + Target) are identical between the 
  #                         results at dil = 0% and dil = *%.
  #
  # Mismatch              = 1 - Overlap, i.e. what proportion of top ranked 
  #                         interactions (L + R + Source + Target) are different 
  #                         between the results at dil = 0% and dil = *%.
  #
  # Randoms               = What proportion of top_ranked interactions at 
  #                         dil = *% are random, dilution produced interactions.
  #
  # Mismatch_from_Randoms = What proportion of mismatch is due to random
  #                         dilution based interactions that happen to be top 
  #                         ranked.
  # 
  # All_mismatch_from_Randoms  =  At a glance, is all the mismatch from Randoms?
  
  
  # lapply rank_overlap over the top rank tibbles, comparing the dilutions to 
  # the OP_0 at each stage.
  overlaps <- list()
  
  for (method in methods_vector) {
    
    if (method == "cellchat") {
      
      overlaps[[method]] <- 
        lapply(top_ranks_OP[[method]], 
               cellchat_rank_overlap, 
               main_ranks = top_ranks_OP[[method]]$OmniPath_0)
      
    } else {
      
      overlaps[[method]] <- 
        lapply(top_ranks_OP[[method]], 
               rank_overlap, 
               main_ranks = top_ranks_OP[[method]]$OmniPath_0)
      
    }

  
  }
  
  
  # add NAs to the end of the overlaps where dilution wasn't possible
  # this way all the overlaps have the same length for tibble construction
  overlaps <- 
    lapply(overlaps, 
           function(x) { c(x, rep(NA, length(dilution_props)+1-length(x)))})
  
  
  
  
  # reformatting overlap as a tibble
  top_ranks_overlap <- as_tibble(overlaps)        %>%
    unnest(cols = all_of(methods_vector))         %>%
    mutate(dilution_prop = c(0, dilution_props))  %>%
    unnest(cols = c(dilution_prop))               %>%
    relocate("dilution_prop")
  
  # removing superfluous values
  rm(overlaps)
  
  
  
  # Top ranked interactions where isRandom = TRUE are products of dilutions.
  # If the diminished top_rank_overlap is exactly equal to the proportion of 
  # diluted interactions in the top_ranks, this indcates that dilution only 
  # messes with top ranks by creating candidates for false detection.
  
  # It could also be possible though that the proportion of dilutions in the 
  # top ranks doesn't fullly explain the diminishing overlap. In this case
  # dilutions may also alter the context such that real interactions that were
  # previously not top_ranked have become top_ranked.
  
  # Inaccuracy purely from random interactions being picked up on as top ranked
  # vs Inaccuracy from pushing previously not top ranked interactions into the
  # top ranks. This is an especially interesting comparison if top_ranked 
  # interactions can e diluted in the resource, as here the removal of previous 
  # top_ranks is felt greater.
  
  # We apply the prop_isRandom function, over every top_rank_df
  # Using lapply and sapply gives a convenient output layout that makes the 
  # formatting easier. 
  top_ranks_randoms <- lapply(top_ranks_OP, sapply, prop_isRandom) 
  
  # Because certain dilutions at higher dilution props might not have been 
  # achievable in respects to not changing top_ranked interactions. Because of
  # this, the sapply output may be short a few variables, which we correct by 
  # adding NAs until every vector that will become a column is has the same 
  # length of dilution_props. These NAs represent that the isRandom column
  # couldn't be analysed here, as no output was created.
  top_ranks_randoms <- 
    lapply(top_ranks_randoms, 
           function(x) { c(x, rep(NA, length(dilution_props)+1-length(x)))})
  
  # We format top_ranks_randoms the way we formatted top_ranks_overlap
  top_ranks_randoms <- top_ranks_randoms         %>%
    data.frame()                                 %>%
    as_tibble()                                  %>%
    mutate(dilution_prop = c(0, dilution_props)) %>%
    unnest(cols = c(dilution_prop))              %>%
    relocate("dilution_prop")                    %>%
    data.frame() #because we plan to do arithmetic operations with this tibble
  
  # The proportion of mismatch between top_rank_dfs is 1- the overlap
  # In order to perform this calculation top_ranks_overlap can't be a tibble
  top_ranks_mismatch                  <- 1 - data.frame(top_ranks_overlap)
  # We correct the dilutions column
  top_ranks_mismatch$dilution_prop    <- top_ranks_overlap$dilution_prop
  
  
  # What proportion of the mismatch is from diluted interactions picked up om
  # as top ranked? NaN = There was no mismatch here.
  mismatch_from_randoms               <- top_ranks_randoms / top_ranks_mismatch
  # Correct the dilutions column
  mismatch_from_randoms$dilution_prop <- top_ranks_randoms$dilution_prop
  
  
  # We store this variable in the environment so the user can find it more easily.
  All_mismatch_from_Randoms <- all.equal(top_ranks_randoms, 
                                         top_ranks_mismatch)
  
  
  # Summarizing all this information in one list makes things clear. 
  # Reconvert everything to tibbles as arithmetic operations should be over
  top_ranks_analysis <- 
    list("Overlap"                   = tibble(top_ranks_overlap),
         "Mismatch"                  = tibble(top_ranks_mismatch),
         "Randoms"                   = tibble(top_ranks_randoms),
         "Mismatch_from_Randoms"     = tibble(mismatch_from_randoms),
         "All_mismatch_from_Randoms" = All_mismatch_from_Randoms)
  
  
  # Get rid of superfluous values
  rm(top_ranks_overlap, 
     top_ranks_mismatch, 
     top_ranks_randoms, 
     mismatch_from_randoms, 
     All_mismatch_from_Randoms)
  
  } # end of subpoint
  
  
}




#------------------------------------------------------------------------------#
# 4. Returning results ------------------------------------------------------
{
  print_Title(
    str_glue("5. Returning results", "                   --  Iteration ", 
             master_seed))
  
  
  # 4.1 Tidying R environment and saving to Outputs under custom name
  {
      
    # stop the stopwatch
    runtime[[str_glue("Iteration Epilogue - Seed ", master_seed)]] <- Sys.time()  
      
    # Summarizing runtime
    metadata <- list("runtime" = runtime)
    
    # If the output was sunk the location of the log is brought to the user's 
    # attention
    if(sink_output == TRUE) {
      
      print(str_glue("Complete log saved at ~/", sink_logfile, "."))
      
      # Keep the environment tidy
      rm(sink_logfile)
      
    }
    
      
    if(liana_warnings == "divert") {
      
      # let the user know where to find the log
      print(str_glue("LIANA warnings saved at ~/", 
                     warning_logfile, "."))
      
      # Keep the environment tidy
      rm(warning_logfile)
      
    }
  
    
    # Removing now-superfluous meta data
    rm(dilution_props, number_ranks, runtime, cellchat_nperms, feature_type, 
       methods_vector, testdata_type, preserve_topology)
    
    
    if(sink_output == TRUE) {
      
      sink() 
      sink(type="message")
      
    }
  
    
  } # end of subpoint

  # 5.3 Bundling Outputs and returning Results
  {
    # Create one bundled object for the script to return
    results  <- list("liana_results_OP"   = liana_results_OP,
                     "resources_OP"       = resources_OP,
                     "top_ranks_OP"       = top_ranks_OP,
                     "top_ranks_analysis" = top_ranks_analysis,
                     
                     "metadata"           = metadata,
                     "testdata"           = testdata)
    
    # Filter it by the outputs the user requested
    results <- results[outputs]
   
    
  }
  
  
}

# Return results
return(results)

} # end of function


  
